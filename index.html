// p5.js Space Invaders Game Example
// “Star Invaders”
// Designed for mobile (touch controls) and desktop
// Google Font "Audiowide" should be included in your HTML/CSS

// Game States: "title", "playing", "levelComplete", "gameOver"
let gameState = "title";

// Global game variables
let score = 0;
let level = 1;
let lives = 3;
let aliens = [];
let missiles = [];
let alienProjectiles = [];
let powerUps = [];
let particles = [];
let ship;
let hudHeight = 40; // HUD takes top 40 pixels
let bg;
let aliensAssembled = false;  // becomes true when aliens finish zooming in

// Timing for title blinking text
let blinkTimer = 0;
let blinkInterval = 30;  // frames

// For touch controls:
let lastTouchX = null;

// preload assets
function preload() {
  // Load fonts, sounds, images here
  // Example: audiowideFont = loadFont('Audiowide-Regular.ttf');
  // For placeholder sound effects, we just create dummy functions
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);
  // Optionally set your font if loaded: textFont(audiowideFont);
  
  // Create the background effect (randomly choose one of two effects)
  bg = random([new StarField(), new WireframeBackground()]);
  
  // Create the ship (initially off–screen, will pop up later)
  ship = new Ship();
  
  // Start first level on game start (but wait until title is dismissed)
  // Level initialization happens on startGame()
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function draw() {
  // Draw background effect
  bg.update();
  bg.display();
  
  // Draw HUD
  drawHUD();
  
  if (gameState === "title") {
    drawTitleScreen();
  }
  else if (gameState === "playing") {
    // Update and display game objects
    updateGame();
    displayGame();
  }
  else if (gameState === "levelComplete") {
    // Show level complete message
    fill(255);
    textSize(32);
    text("Level Complete!", width / 2, height / 2);
    // After a pause, automatically begin next level
    if (frameCount % 120 === 0) {
      nextLevel();
    }
  }
  else if (gameState === "gameOver") {
    fill(255, 0, 0);
    textSize(32);
    text("Game Over", width / 2, height / 2);
    textSize(16);
    text("Tap to Restart", width / 2, height / 2 + 40);
  }
}

// HUD drawing function
function drawHUD() {
  fill(0, 150);
  noStroke();
  rect(0, 0, width, hudHeight);
  
  fill(255);
  textSize(16);
  textAlign(LEFT, CENTER);
  text("Score: " + score, 10, hudHeight / 2);
  
  textAlign(CENTER, CENTER);
  text("Level: " + level, width / 2, hudHeight / 2);
  
  textAlign(RIGHT, CENTER);
  text("Lives: " + lives, width - 10, hudHeight / 2);
}

// Title screen drawing
function drawTitleScreen() {
  fill(255);
  textSize(48);
  text("Star Invaders", width / 2, height / 2 - 40);
  
  blinkTimer++;
  if (blinkTimer % (2 * blinkInterval) < blinkInterval) {
    textSize(24);
    text("Tap to Start", width / 2, height / 2 + 20);
  }
}

// Update game objects
function updateGame() {
  // Only allow ship actions if aliens are assembled and ship is visible
  if (aliensAssembled) {
    ship.update();
  } else {
    // If aliens are still assembling, update their positions
    for (let a of aliens) {
      a.update();
    }
    // When aliens finish assembling, bring up the ship:
    if (allAliensAssembled()) {
      aliensAssembled = true;
      ship.popUp();
    }
  }
  
  // Update missiles
  for (let i = missiles.length - 1; i >= 0; i--) {
    missiles[i].update();
    if (missiles[i].offscreen()) {
      missiles.splice(i, 1);
    }
  }
  
  // Update alien projectiles
  for (let i = alienProjectiles.length - 1; i >= 0; i--) {
    alienProjectiles[i].update();
    if (alienProjectiles[i].offscreen()) {
      alienProjectiles.splice(i, 1);
    }
  }
  
  // Update power-ups
  for (let i = powerUps.length - 1; i >= 0; i--) {
    powerUps[i].update();
    if (powerUps[i].collected || powerUps[i].offscreen()) {
      powerUps.splice(i, 1);
    }
  }
  
  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    if (particles[i].finished()) {
      particles.splice(i, 1);
    }
  }
  
  // Check collisions (only when ship is active)
  if (aliensAssembled) {
    checkCollisions();
  }
}

// Display game objects
function displayGame() {
  // Draw aliens
  for (let a of aliens) {
    a.display();
  }
  
  // Draw ship (if visible)
  ship.display();
  
  // Draw missiles
  for (let m of missiles) {
    m.display();
  }
  
  // Draw alien projectiles
  for (let ap of alienProjectiles) {
    ap.display();
  }
  
  // Draw power-ups
  for (let p of powerUps) {
    p.display();
  }
  
  // Draw particles
  for (let p of particles) {
    p.display();
  }
}

// Check collisions between missiles and aliens, ship and projectiles/power-ups etc.
function checkCollisions() {
  // Missile vs Alien
  for (let i = missiles.length - 1; i >= 0; i--) {
    for (let j = aliens.length - 1; j >= 0; j--) {
      if (missiles[i].hits(aliens[j])) {
        // Alien takes damage
        aliens[j].takeDamage();
        // Remove missile on hit
        missiles.splice(i, 1);
        // If alien dies, add explosion particles and update score
        if (aliens[j].isDead()) {
          score += 10;
          createExplosion(aliens[j].x, aliens[j].y);
          // Occasionally release a power-up:
          if (random() < 0.2) {
            powerUps.push(new PowerUp(aliens[j].x, aliens[j].y));
          }
          aliens.splice(j, 1);
        }
        break;
      }
    }
  }
  
  // Alien projectile vs Ship
  for (let i = alienProjectiles.length - 1; i >= 0; i--) {
    if (alienProjectiles[i].hits(ship)) {
      ship.takeDamage();
      createExplosion(ship.x, ship.y);
      alienProjectiles.splice(i, 1);
      if (ship.isDead()) {
        lives--;
        if (lives <= 0) {
          gameState = "gameOver";
        } else {
          // Reset ship position and state
          ship.reset();
        }
      }
    }
  }
  
  // Alien reaching ship level (descended too low)
  for (let a of aliens) {
    if (a.y + a.size/2 >= ship.y - ship.size/2) {
      ship.takeDamage();
      createExplosion(ship.x, ship.y);
      if (ship.isDead()) {
        lives--;
        if (lives <= 0) {
          gameState = "gameOver";
        } else {
          ship.reset();
        }
      }
    }
  }
  
  // Power-up vs Ship
  for (let i = powerUps.length - 1; i >= 0; i--) {
    if (powerUps[i].hits(ship)) {
      ship.powerUp();
      powerUps[i].collected = true;
    }
  }
  
  // Check if level is complete (all aliens eliminated)
  if (aliens.length === 0 && aliensAssembled) {
    gameState = "levelComplete";
  }
}

// Create explosion particle effect at (x, y)
function createExplosion(x, y) {
  for (let i = 0; i < 20; i++) {
    particles.push(new Particle(x, y));
  }
  // Placeholder: play explosion sound
  playSound("explosion");
}

// Placeholder sound function
function playSound(name) {
  // You can later link sound files here.
  // For example, if (name === "missile") { missileSound.play(); }
}

// Begin the game from the title screen
function startGame() {
  gameState = "playing";
  score = 0;
  level = 1;
  lives = 3;
  aliensAssembled = false;
  ship.reset();
  missiles = [];
  alienProjectiles = [];
  powerUps = [];
  particles = [];
  
  // Choose a new background effect for the level
  bg = random([new StarField(), new WireframeBackground()]);
  
  // Create aliens formation
  aliens = [];
  // 4 rows, 5 columns; starting offscreen left/right
  let rows = 4, cols = 5;
  let spacingX = width / (cols + 1);
  let startY = hudHeight + 60;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // Start aliens offscreen on left/right alternately:
      let offscreenX = (c % 2 === 0) ? -50 : width + 50;
      let targetX = spacingX * (c + 1);
      let targetY = startY + r * 50;
      aliens.push(new Alien(offscreenX, targetY, targetX));
    }
  }
}

// Prepare next level
function nextLevel() {
  level++;
  aliensAssembled = false;
  ship.reset();
  missiles = [];
  alienProjectiles = [];
  powerUps = [];
  particles = [];
  
  // Increase difficulty by increasing descent speed of aliens
  for (let a of aliens) {
    a.increaseSpeed(0.5);
  }
  
  // Randomly choose a new background for the level
  bg = random([new StarField(), new WireframeBackground()]);
  
  // Recreate aliens formation for new level
  aliens = [];
  let rows = 4, cols = 5;
  let spacingX = width / (cols + 1);
  let startY = hudHeight + 60;
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      let offscreenX = (c % 2 === 0) ? -50 : width + 50;
      let targetX = spacingX * (c + 1);
      let targetY = startY + r * 50;
      aliens.push(new Alien(offscreenX, targetY, targetX, level));
    }
  }
  gameState = "playing";
}

// Check if all aliens have reached their target (assembled)
function allAliensAssembled() {
  for (let a of aliens) {
    if (!a.assembled) return false;
  }
  return true;
}

// Touch and mouse input handling:
function touchStarted() {
  // In title or game over, tapping starts/restarts the game
  if (gameState === "title" || gameState === "gameOver") {
    startGame();
    return false; // prevent default
  }
  
  // If game is playing and ship is active, fire missile
  if (gameState === "playing" && aliensAssembled) {
    ship.fire();
  }
  
  // Record initial touch x-position for ship movement
  lastTouchX = mouseX;
  return false;
}

function touchMoved() {
  if (gameState === "playing" && aliensAssembled) {
    // Calculate difference and move ship accordingly
    let dx = mouseX - lastTouchX;
    ship.move(dx);
    lastTouchX = mouseX;
  }
  return false;
}

function mouseDragged() {
  // Support mouse dragging for desktop
  touchMoved();
}

function mousePressed() {
  touchStarted();
}

// ---------------
// Classes
// ---------------

// Ship class: represents the player's spaceship
class Ship {
  constructor() {
    this.size = 40;
    this.x = width / 2;
    // Start below canvas, then pop up when aliens assembled
    this.y = height + this.size;
    this.targetY = height - this.size - 10;
    this.speed = 5;
    this.health = 3;
    this.active = false;
    this.tilt = 0; // for tilt animation
    this.twinShot = false; // power-up flag
  }
  
  update() {
    // For tilt effect, gradually return to 0
    this.tilt *= 0.9;
  }
  
  display() {
    push();
    translate(this.x, this.y);
    rotate(radians(this.tilt));
    // Draw a simple wireframe F-22 top view (triangle-like shape)
    stroke(255);
    noFill();
    beginShape();
    vertex(0, -this.size/2);
    vertex(this.size/2, this.size/2);
    vertex(0, this.size/4);
    vertex(-this.size/2, this.size/2);
    endShape(CLOSE);
    pop();
  }
  
  move(dx) {
    this.x += dx;
    // Add a tilt effect relative to movement
    this.tilt = dx * 0.5;
    this.x = constrain(this.x, 20, width - 20);
  }
  
  // Called when aliens are assembled: animate ship popping up
  popUp() {
    // Simple animation: move upward until targetY is reached
    let interval = setInterval(() => {
      this.y -= 5;
      if (this.y <= this.targetY) {
        this.y = this.targetY;
        clearInterval(interval);
        this.active = true;
      }
    }, 16);
  }
  
  fire() {
    // Fire a missile from the ship.
    playSound("missile");
    missiles.push(new Missile(this.x, this.y - this.size/2));
    if (this.twinShot) {
      // Also fire a second missile from a slightly offset position
      missiles.push(new Missile(this.x - 10, this.y - this.size/2));
    }
  }
  
  takeDamage() {
    // Flash effect could be triggered here.
    // For now, simply reduce health.
    this.health--;
    // Trigger damage flash (for a few frames, you can modify display method)
  }
  
  isDead() {
    return this.health <= 0;
  }
  
  reset() {
    this.x = width / 2;
    this.y = height + this.size;
    this.health = 3;
    this.active = false;
    this.twinShot = false;
    // Pop up again after short delay
    setTimeout(() => { this.popUp(); }, 500);
  }
  
  powerUp() {
    // Activate twin shot for a short period (or permanently until next level)
    this.twinShot = true;
    // You could set a timeout to disable twin shot later.
  }
}

// Missile class: fired by the ship
class Missile {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 5;
    this.speed = 8;
  }
  
  update() {
    this.y -= this.speed;
  }
  
  display() {
    fill(255, 255, 0);
    noStroke();
    ellipse(this.x, this.y, this.r*2);
  }
  
  offscreen() {
    return (this.y < 0);
  }
  
  hits(alien) {
    // Simple circle collision detection
    let d = dist(this.x, this.y, alien.x, alien.y);
    return (d < this.r + alien.size/2);
  }
}

// Alien class
class Alien {
  constructor(x, targetY, targetX, level = 1) {
    this.x = x;
    this.y = random(50, 150); // start at some y position; can adjust as needed
    this.targetX = targetX;
    this.targetY = targetY;
    this.size = 40;
    this.speed = 3 + level * 0.5; // speed increases with level
    this.assembled = false;
    this.health = 1;  // can be increased for tougher aliens
    this.flashTimer = 0;
  }
  
  update() {
    if (!this.assembled) {
      // Move toward the targetX position horizontally
      this.x = lerp(this.x, this.targetX, 0.05);
      // And also gradually move down to targetY
      this.y = lerp(this.y, this.targetY, 0.05);
      if (abs(this.x - this.targetX) < 2 && abs(this.y - this.targetY) < 2) {
        this.x = this.targetX;
        this.y = this.targetY;
        this.assembled = true;
      }
    }
    else {
      // Once assembled, aliens descend steadily
      this.y += this.speed * 0.02 * level; // descent speed increases with level
      
      // Occasionally fire an alien projectile (low probability each frame)
      if (random() < 0.001 * level) {
        alienProjectiles.push(new AlienProjectile(this.x, this.y + this.size/2));
        playSound("alienFire");
      }
    }
    
    // Handle flash timer for damage effect
    if (this.flashTimer > 0) {
      this.flashTimer--;
    }
  }
  
  display() {
    push();
    translate(this.x, this.y);
    if (this.flashTimer > 0) {
      // Flash effect: alternate fill
      stroke(255);
      fill(255);
    } else {
      stroke(0, 255, 0);
      fill(0, 200, 0);
    }
    // Draw the classic alien – here using a simple shape resembling 👾
    // You can replace this with an animated sprite if desired.
    beginShape();
    vertex(-this.size/2, -this.size/4);
    vertex(0, -this.size/2);
    vertex(this.size/2, -this.size/4);
    vertex(this.size/2, this.size/4);
    vertex(0, this.size/2);
    vertex(-this.size/2, this.size/4);
    endShape(CLOSE);
    pop();
  }
  
  takeDamage() {
    this.flashTimer = 20; // frames to flash
    this.health--;
  }
  
  isDead() {
    return this.health <= 0;
  }
  
  increaseSpeed(inc) {
    this.speed += inc;
  }
}

// Alien projectile class
class AlienProjectile {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 6;
    this.speed = 2;  // slow projectile
  }
  
  update() {
    this.y += this.speed;
  }
  
  display() {
    fill(255, 0, 0);
    noStroke();
    ellipse(this.x, this.y, this.r*2);
  }
  
  offscreen() {
    return (this.y > height);
  }
  
  hits(ship) {
    let d = dist(this.x, this.y, ship.x, ship.y);
    return (d < this.r + ship.size/2);
  }
}

// PowerUp class
class PowerUp {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.size = 20;
    this.speed = 2;
    this.collected = false;
  }
  
  update() {
    this.y += this.speed;
  }
  
  display() {
    push();
    translate(this.x, this.y);
    stroke(255, 215, 0);
    fill(255, 223, 0, 150);
    ellipse(0, 0, this.size);
    pop();
  }
  
  offscreen() {
    return (this.y > height);
  }
  
  hits(ship) {
    let d = dist(this.x, this.y, ship.x, ship.y);
    return (d < (this.size + ship.size) / 2);
  }
}

// Particle class for explosion effects
class Particle {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.lifetime = 60;
    this.speedX = random(-3, 3);
    this.speedY = random(-3, 3);
    this.size = random(2, 4);
  }
  
  update() {
    this.x += this.speedX;
    this.y += this.speedY;
    this.lifetime--;
  }
  
  display() {
    noStroke();
    fill(255, this.lifetime * 4);
    ellipse(this.x, this.y, this.size);
  }
  
  finished() {
    return this.lifetime <= 0;
  }
}

// StarField background (parallax pale dots)
class StarField {
  constructor() {
    this.stars = [];
    for (let i = 0; i < 100; i++) {
      this.stars.push({
        x: random(width),
        y: random(height),
        speed: random(0.2, 1)
      });
    }
  }
  
  update() {
    for (let star of this.stars) {
      star.y += star.speed;
      if (star.y > height) {
        star.y = 0;
        star.x = random(width);
      }
    }
  }
  
  display() {
    background(10);
    noStroke();
    fill(200);
    for (let star of this.stars) {
      ellipse(star.x, star.y, 2);
    }
  }
}

// Wireframe background (flat square wireframe)
class WireframeBackground {
  constructor() {
    // Pick a random pale colour
    this.col = color(random(150, 200), random(150, 200), random(150, 200));
    this.spacing = 40;
  }
  
  update() {
    // For a simple parallax, we could animate offset positions if desired.
    // Here, we keep it static.
  }
  
  display() {
    background(20);
    stroke(this.col);
    noFill();
    for (let x = 0; x < width; x += this.spacing) {
      for (let y = hudHeight; y < height; y += this.spacing) {
        rect(x, y, this.spacing, this.spacing);
      }
    }
  }
}
